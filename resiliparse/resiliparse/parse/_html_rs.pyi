# Copyright 2024 Janek Bevendorff
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import enum
from typing import Callable, Iterable, Iterator, List, Optional, overload, Tuple, Sequence


class NodeType(enum.Enum):
    ELEMENT: int = 0x01
    ATTRIBUTE: int = 0x02
    TEXT: int = 0x03
    CDATA_SECTION: int = 0x04
    ENTITY_REFERENCE: int = 0x05
    ENTITY: int = 0x06
    PROCESSING_INSTRUCTION: int = 0x07
    COMMENT: int = 0x08
    DOCUMENT: int = 0x09
    DOCUMENTDOMNodeYPE: int = 0x0A
    DOCUMENT_FRAGMENT: int = 0x0B
    NOTATION: int = 0x0C
    LAST_ENTRY: int = 0x0D


class DOMCollection(Sequence[DOMNode]):
    def get_element_by_id(self, element_id: str, case_insensitive: bool = False) -> Optional[DOMNode]: ...
    def get_elements_by_attr(self, attr_name: str, attr_value: str, case_insensitive: bool = False) -> DOMCollection[DOMNode]: ...
    def get_elements_by_class_name(self, class_name: str) -> DOMCollection[DOMNode]: ...
    def get_elements_by_tag_name(self, tag_name: str) -> DOMCollection[DOMNode]: ...
    def query_selector(self, selector: str) -> Optional[DOMNode]: ...
    def query_selector_all(self, selector: str) -> DOMCollection[DOMNode]: ...
    def matches(self, selector: str) -> bool: ...

    @overload
    def __getitem__(self, index: int) -> DOMNode: ...
    @overload
    def __getitem__(self, index: slice) -> Sequence[DOMNode]: ...
    def __len__(self) -> int: ...


class DOMElementClassList(Sequence[str]):
    def add(self, class_name: str): ...
    def remove(self, class_name: str): ...

    @overload
    def __getitem__(self, index: int) -> str: ...
    @overload
    def __getitem__(self, index: slice) -> Sequence[str]: ...
    def __len__(self) -> int: ...


class DOMNode(Iterable[DOMNode]):
    @property
    def type(self) -> NodeType: ...

    @property
    def first_child(self) -> Optional[DOMNode]: ...
    @property
    def first_element_child(self) -> Optional[DOMNode]: ...
    @property
    def last_element_child(self) -> Optional[DOMNode]: ...
    @property
    def child_nodes(self) -> List[DOMNode]: ...
    @property
    def parent(self) -> Optional[DOMNode]: ...
    @property
    def next(self) -> Optional[DOMNode]: ...
    @property
    def prev(self) -> Optional[DOMNode]: ...
    @property
    def next_element(self) -> Optional[DOMNode]: ...
    @property
    def prev_element(self) -> Optional[DOMNode]: ...

    @property
    def tag(self) -> str: ...
    @property
    def value(self) -> Optional[str]: ...
    @property
    def text(self) -> Optional[str]: ...
    @property
    def html(self) -> Optional[str]: ...
    @property
    def id(self) -> Optional[str]: ...
    @property
    def class_name(self) -> Optional[str]: ...
    @property
    def class_list(self) -> DOMElementClassList: ...
    @property
    def attrs(self) -> Tuple[str]: ...
    def __getitem__(self, attr_name: str) -> str: ...
    def __setitem__(self, attr_name: str, attr_value: str): ...
    def __delitem__(self, attr_name: str): ...

    def hasattr(self, attr_name: str) -> bool: ...
    def getattr(self, attr_name: str, default_value: Optional[str]) -> Optional[str]: ...
    def setattr(self, attr_name: str, attr_value: str): ...
    def delattr(self, attr_name: str): ...

    def get_element_by_id(self, element_id: str, case_insensitive: bool = False) -> Optional[DOMNode]: ...
    def get_elements_by_attr(self, attr_name: str, attr_value: str, case_insensitive: bool = False) -> DOMCollection: ...
    def get_elements_by_class_name(self, class_name: str) -> DOMCollection: ...
    def get_elements_by_tag_name(self, tag_name: str) -> DOMCollection: ...
    def query_selector(self, selector: str) -> Optional[DOMNode]: ...
    def query_selector_all(self, selector: str) -> DOMCollection: ...
    def matches(self, selector: str) -> bool: ...

    def append_child(self, node: DOMNode) -> DOMNode: ...
    def insert_before(self, node: DOMNode, reference: DOMNode) -> DOMNode: ...
    def replace_child(self, new_child: DOMNode, old_child: DOMNode) -> DOMNode: ...
    def remove_child(self, node: DOMNode) -> DOMNode: ...
    def decompose(self): ...

    def __iter__(self) -> Iterator[DOMNode]: ...


class HTMLTree:
    @staticmethod
    def parse(document: str) -> Optional[HTMLTree]: ...
    @staticmethod
    def parse_from_bytes(document: bytes, encoding: str = 'utf-8', errors: str = 'ignore') -> Optional[HTMLTree]: ...

    def create_element(self, tag_name: str) -> Optional[DOMNode]: ...
    def create_text_node(self, text: str) -> Optional[DOMNode]: ...

    @property
    def document(self) -> Optional[DOMNode]: ...
    @property
    def head(self) -> Optional[DOMNode]: ...
    @property
    def body(self) -> Optional[DOMNode]: ...
    @property
    def title(self) -> Optional[str]: ...


class DOMContext:
    def __init__(self):
        self.node: Optional[DOMNode] = None
        self.depth: int = 0


def traverse_dom(base_node: DOMNode,
                 start_callback: Callable[[DOMContext], None],
                 end_callback: Optional[Callable[[DOMContext], None]] = None,
                 context: Optional[DOMContext] = None,
                 elements_only: bool = False): ...
